<html>
<head>
<script  type="application/javascript" src="brains.js"></script>
<script type="application/javascript" src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=IM+Fell+English+SC&display=swap" rel="stylesheet">
<!-- Include Tailwind CSS from CDN -->
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
</head>
<body>
<div id="app" class="w-full">
  <nav class="bg-blue-500 p-4">
    <div class="max-w-7xl mx-auto flex justify-between items-center">
        <a href="#" class="text-white font-semibold hover:underline pr-4" @click="showSection('sheets')">Sheets</a>
        <a href="#" class="text-white font-semibold hover:underline pr-4" @click="showSection('blocks')">Blocks</a>
        <!--<a href="#" class="text-white font-semibold hover:underline" @click="showSection('resources')">Resources</a>-->
        <a href="#" class="text-white font-semibold hover:underline" @click="showSection('admin')">Admin</a>
        <a href="#" class="text-white font-semibold hover:underline" @click="showSection('itemDB')">Items</a>
    </div>
</nav>
    <div v-show="activeSection === 'sheets'" id="sheet-container" class="flex flex-col w-full items-center justify-center">
      <div class="w-11/12 text-white text-lg mt-3 font-bold">My Unique Characters</div>
      <div class="w-11/12 text-white text-md mt-1 mb-1">Below is a list of your unique creatures in this campaign, 
        you can create a sheet for each one.</div>
      <div class="w-11/12">
        <button class="bg-blue-500 w-3/6 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded" @click="refreshCreatures()">Refresh Creatures</button>
        <div class="w-full flex flex-wrap mt-2">
        <div class="w-3/6 text-white flex flex-col " v-for="(creature, index) in playersCreatures">
        <span>{{ truncateString(creature.name, 25) }}</span>
        <button class="bg-blue-500 w-full hover:bg-blue-700 text-white font-bold py-2 px-4 rounded" v-if="hasSheet(creature.id) === false" @click="createSheet(creature.id)">Create Sheet</button>
        <button class="bg-blue-500 w-11/12 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded" v-else @click="setActiveSheet(creature.id)">View Sheet</button>
        </div>
        </div>
        <span class="text-white">{{ updateMessage  }}</span>
        <div class="w-12/12" v-for="(character, index) in characters" v-if="character.sheet != null" :key="index" v-show="activeSheet == character.id">
          <form :id="character.id" class="parchment mt-3 w-full">
            <div class="parchment_header flex justify-between">
            <div class="mr-4">
            <h1 class="text-4xl underline mb-1">{{ character.name }}</h1>
            <div v-for="(value, key) in character.sheet" :key="key"  v-if="value.type == 'B'" class="mb-1">
                    <label>{{ removeUnderline(key) }}:</label>  
                    <input type="text" :key="key" :name="key" v-model="value.value" />
            </div>
        </div>
        <div class="ml-4">
            <span v-if="character.picture">  
            <img class="img-border" v-if="character.picture ":src="character.picture" alt="Image" />  
            </span> 
            <span v-else>
            <img class="img-border" src="https://placehold.co/275x275" alt="Image" />
            </span>
            <div>
            <div v-for="(value, key) in character.sheet" :key="key"  v-if="value.type == 'B2'" class="mt-3 mb-1">
              <label>{{ removeUnderline(key) }}:</label>  
              <input type="text" :key="key" :name="key" v-model="value.value"  v-enlarge="value.value"
 />
            </div>
            </div> 
            
            </div>
            </div>
            <hr class="bg-black border-black" />
            <div>
              <span
              @click="activeSheetTab = 'core'"
              :class="[ 'inline-block p-4 border-b-2 rounded-t-lg hover:text-gray-600 dark:hover:text-gray-300', activeSheetTab === 'core' ? 'border-blue-500 text-blue-500' : 'border-transparent']"
             >
              Core Stats
            </span>
              <span @click="activeSheetTab = 'inventory'"  :class="[ 'inline-block p-3 border-b-2 rounded-t-lg hover:text-gray-600 dark:hover:text-gray-300', activeSheetTab === 'inventory' ? 'border-blue-500 text-blue-500' : 'border-transparent']">Inventory</span>
              <span @click="activeSheetTab = 'spells'"  :class="[ 'inline-block p-3 border-b-2 rounded-t-lg hover:text-gray-600 dark:hover:text-gray-300', activeSheetTab === 'spells' ? 'border-blue-500 text-blue-500' : 'border-transparent']">Spells & Attacks</span>
              <span @click="activeSheetTab = 'bio'"  :class="[ 'inline-block p-3 border-b-2 rounded-t-lg hover:text-gray-600 dark:hover:text-gray-300', activeSheetTab === 'bio' ? 'border-blue-500 text-blue-500' : 'border-transparent']">Bio</span>
              <span @click="activeSheetTab = 'buffs'"  :class="[ 'inline-block p-3 border-b-2 rounded-t-lg hover:text-gray-600 dark:hover:text-gray-300', activeSheetTab === 'buffs' ? 'border-blue-500 text-blue-500' : 'border-transparent']">Buffs & Gear</span>
            </div>
            <hr class="bg-black border-black mb-2" />
            <div class="flex flex-col md:flex-row w-full mt-2" v-show="activeSheetTab === 'core'">
            <div class="flex flex-wrap w-full mb-1">
              <div v-for="(value, key) in character.sheet" :key="key"  v-if="value.type == 'C'" class="mb-1 w-3/6">
           
                  <div class="flex flex-wrap">
                  <label>{{ key }}</label>  
                  <input type="text" :key="key" :name="key" v-model="value.value" />
              </div>
                <!-- another field is needed here, which is calculated from the value of the stat, using the DND formula -->
              <label class="w-full">Modifier</label>
              <span>{{ calculateModifier(value.value) }}</span>
              </div>
            </div>
             <hr class="bg-black border-black" />
             <!-- SKILLS SECTION -->
             <div class="bg-gray-200 p-2 w-full shadow shadow-outline shadow-inner border mt-2 mb-2">
                <b class="underline">Skills</b>
                <div v-for="(value, key) in skills" :key="key" class="section-skills">
                  <label>{{ value.name }}</label> 
                | {{ shortenStat(value.associated_stat) }}
                <template v-if="character.sheet.proficiencies.value != null">
                  <span v-if="findSkillProf(character.sheet.proficiencies.value.skill, value.id)">| <b>proficient</b></span>
                </template>
                </div>
            </div>
            <div v-for="(value, key) in character.sheet" :key="key"  v-if="value.type == 'M'" class="section-header mb-1">
                    <div class="flex flex-col">
                    <label>{{ removeUnderline(key) }}</label>  
                    <input class="w-2/3" type="text" :key="key" :name="key" v-model="value.value" />
                    </div>
              </div>
              <button class="bg-blue-500 w-24 hover:bg-blue-700 text-white font-bold mt-2 py-2 px-4 rounded" @click.prevent="updateSheet(character.sheets.id)">Update</button>
              </div>
              <div class="flex flex-col mb-1" v-show="activeSheetTab === 'inventory'">
                  <hr class="bg-black border-black" />
                  <div class="flex md:flex-row w-full flex-wrap border-solid border-2 bg-slate-800  border-y-slate-700 border-x-slate-300 justify-evenly pt-4 pb-4">
                      <div v-for="(count, itemId) in character.sheet.ItemCounts.value" :key="itemId" 
                      :class="[rarityColors
                      [character.sheet.sheetsItems.value.find(item => item.item_id === Number(itemId)).item.rarity_id], 'p-1 cursor-pointer border-solid border-4 bg-contain bg-slate-900 m-1 bg-no-repeat flex flex-col justify-between w-1/5 max-w-1/5 h-24']"
                            :style="{ backgroundImage: 'url(' + character.sheet.sheetsItems.value.find(item => item.item_id === Number(itemId)).item.image_link + ')' }"
                            @click.prevent="openMenu(itemId)"
                            >
                        <!-- IF the item is a consumable, we should also have a "consume one button for cases where a player has a large amount of the same consumable."-->
                        <div class="text-white">{{ count }}x</div>
                        <div class="text-white">{{ character.sheet.sheetsItems.value.find(item => item.item_id === Number(itemId)).item.name }}</div>
                        <div v-if="openMenus[itemId]" class="bg-white p-2 mt-2 rounded shadow h-24 z-0">
                          <template v-if="character.sheet.sheetsItems.value.find(item => item.item_id === Number(itemId)).item.type_id === 3" type="button" @click.prevent="useConsumable(character.sheet.sheetsItems.value.find(item => item.item_id === Number(itemId)), character.id, 'item')">
                          <span>Use 1</span>
                          <hr class="bg-black border-black" />
                        </template>
                          <span @click.prevent="manageItemType(character, itemId)" class=" p-1">Manage</span>
                          <hr class="bg-black border-black" />

                        </div>
                        <!--<button @click.prevent="manageItemType(character, itemId)" class="bg-green-400 rounded text-white p-1">Manage</button>-->
                    
                      </div>
                      </div>
              <div class="flex flex-col mt-2" v-for="(item, key) in character.sheet.managedItems.value">
                    <span class="font-bold">{{ item.item.name }}</span>
                    <span v-if="item.item.type_id === 2">{{ item.item.attributes.damage }} {{ item.item.attributes.damage_type }} damage.</span>
                    <button class="bg-red-400 w-3/6 text-white font-bold mb-2 rounded">Sell</button>
                    <button v-if="(item.item.type_id === 1 || item.item.type_id === 2 || item.item.type_id === 4) && (item.isEquipped === null || item.isEquipped === false) && (item.item.attributes.slots === null || item.item.attributes.slots == undefined)" class="w-3/6 bg-green-400 text-white font-bold rounded" @click.prevent="equipItem(character.id, item.id)">Equip</button>
                    <div v-if="(item.item.type_id === 1 || item.item.type_id === 2 || item.item.type_id === 4) && (item.isEquipped === null || item.isEquipped === false) && (item.item.attributes.slots != null)">
                    <span class="w-3/6">Equip as:</span>
                    <select v-model="this.selectedSlot">
                      <option v-for="(slot, key) in item.item.attributes.slots" :key="key" :value="slot">{{ slot }}</option>
                    </select>
                    <button class="bg-green-400 rounded text-white p-1" @click.prevent="equipItem(character.id, item.id, this.selectedSlot)">Equip</button>
                    </div>
                    <button v-else-if="(item.item.type_id === 1 || item.item.type_id === 2 || item.item.type_id === 4) && item.isEquipped === true" class="w-3/6 bg-green-400 text-white font-bold rounded" @click.prevent="unEquipItem(character.id, item.id)">Unequip</button>
                    <button v-else-if="item.item.type_id === 3" class="w-3/6 bg-green-400 text-white font-bold rounded" type="button" @click.prevent="useConsumable(item, character.id, 'item')">Consume</button>
                    <hr class="bg-black border-black mt-1 mb-2" />
                    </div>
                </div>
                <div class="flex flex-col md:flex-row" v-show="activeSheetTab === 'spells'">
                    <label class="w-full">Attacks</label>
                          
                        <div class="flex flex-col mt-1" v-if="character.sheet.sheetsItems != null || character.sheet.sheetsItems != undefined" v-for="(item, key) in character.sheet.sheetsItems.value.filter(filterByEquipped)">
                            <div v-if="item.item.attributes.damage != null">
                              <span>{{item.slot}}: {{ item.item.name }} | {{ item.item.attributes.damage }} {{ item.item.attributes.damage_type }}
                                <span v-if="character.sheet.proficiencies.value.weapon.includes(item.item.attributes.weapon_type)"></span>
                              </span>
                              <button class="bg-green-400 rounded text-white p-1" @click.prevent="makeAttackRoll(character.id, item.item, 'attack')">To Hit</button>
                              <button class="bg-green-400 rounded text-white p-1" @click.prevent="makeDamageRoll(character.id, item, 'damage')">Damage</button>
                              
                            </div>
                          </div>
                    <!-- Here we need to look at a characters equipped items (all slots) and see if they have an attack associated with them
                    Attacks will have a "damage" value, which will be a dice roll, and a "damage_type" value, which will be a string. e.g. 2d6 Slashing Damage.
                     We will also need to determine, from their proficiencies, if they are proficient with the weapon and if they are add their profiency bonus. 
                      Then we need to factor in any buffs that might also provide a modifier.
                      {"slots": ["mainHand", "offHand"], "damage": "1d6", "weight": 2, "damage_type": "slashing", "weapon_type": "simple", "isEquippable": true}
                    -->
                    <label class="w-full font-bold">Spells</label>
                    <div class="flex flex-col" v-if="character.sheet.spells.value != undefined || character.sheet.spells.value != null">
                          <span>Cantrips known: {{ character.sheet.spells.value.cantrips_known }}</span>
                          <span>Spells known: {{ character.sheet.spells.value.spells_known }}</span>
                          <span>Spell Slots Total:</span>
                          <div v-for="(spell_slot, key) in character.sheet.spells.value.spell_slots">
                            <span>Level {{ key }}: {{ spell_slot }}</span>
                          </div>
                          <span>Spell Slot Counter:</span>
                          <div v-for="(count, key) in character.sheet.spells.value.spell_slots" :key="key" class="flex flex-col w-full">
                            <span  class="font-bold">Level {{ key }}:</span>
                            <div class="flex w-full">
                            <div v-for="n in count" :key="n" :class="{ 'used-diamond': n >= character.sheet.spells.value.spell_slots_remaining[key], 'diamond': n <= character.sheet.spells.value.spell_slots_remaining[key]}">
                            </div>
                            </div>
                          </div>
              
                          <div v-if="character.sheet.spellData != undefined || character.sheet.spellData != null  " v-for="(spell, key) in character.sheet.spellData.value" class="flex flex-col">
                            <span><span class="font-bold">{{ spell.name }}</span><span> | {{ spell.level }}</span></span>
                            <span>{{ spell.description }}</span>
                            <!-- if the spell is a cantrip-->
                            <div v-if="spell.level_id == 1">
                              <button v-if="spell.attributes.ranged_spell_attack == true" class="bg-green-400 rounded text-white p-1" @click.prevent="makeAttackRoll(character.id, spell,'range_spell_attack')">Attack</button>
                              <button v-else class="bg-green-400 rounded text-white p-1">Cast</button>
                            <!-- if the player has a slot at the level of the spell or greater (up casting)-->
                                </div>
                          </div>
                  </div>
                </div>
                <div class="flex flex-col md:flex-row" v-show="activeSheetTab === 'bio'">
                  <div class="w-full mt-2">
                    <div v-for="(value, key) in character.sheet" :key="key"  v-if="value.type == 'F'" class="section-header mb-1 flex flex-col">
                        <label class="underline font-bold mt-1">{{ removeUnderline(key) }}</label> 
                        <textarea v-if="key == 'features'" :key="key" :name="key" v-model="value.value" class="w-full h-64">{{ value }}</textarea>
                        <textarea v-else :key="key" :name="key" v-model="value.value" class="w-full h-32">{{ value }}</textarea>
                    </div>
                  </div>

                </div>
              <div class="flex flex-col md:flex-row" v-show="activeSheetTab === 'buffs'">
                <span>Equipment</span>
                <!-- loop through character.sheet.items.value which have sheet_items.isEquipped set as true  -->
                    <!-- we must process this array further to ensure only one of each equip item appears.-->
                <template v-for="(item) in character.sheet.sheetsItems.value">
                  <div v-if="item.isEquipped" class="flex flex-col">
                      <div v-if="item.slot == 'helmet'">
                        <span>Helmet:</span>
                        <span>{{ item.item.name }}</span>
                       </div>
                        <div v-else-if="item.slot == 'armour'">
                        <span>Armour:</span>
                        <span>{{ item.item.name }}</span>
                      </div>
                      <div v-else-if="item.slot == 'mainHand'">
                        <span>Main Hand:</span>
                        <span>{{ item.item.name }}</span>
                      </div>
                      <div v-else-if="item.slot == 'offHand'">
                        <span>Off Hand:</span>
                        <span>{{ item.item.name }}</span>
                      </div>
                      <button class=" w-3/6 bg-red-400 text-white font-bold rounded" @click.prevent="unEquipItem(character.id, item.id)">un-equip</button>
                  </div>
                </template>

                <hr class="bg-black border-black mt-1 mb-2" />
                <span>Buffs</span>
                  <div v-for="(value, key) in character.sheet.buffs.value" :key="key" class="section-header mb-1 flex flex-col">
                    <p v-if="value.name">{{ removeUnderline(value.name) }} : {{ value.effects.meta }}</p>
                    <button v-if="getEquippedItemForBuff(character.id, value.id)" class="bg-red-400 w-3/6 text-white font-bold mb-2 rounded">Unequip to remove</button>
                    <button v-else class="bg-red-400 w-3/6 text-white font-bold mb-2 rounded" @click.prevent="removeBuff(character.id, value.id)">Remove Buff</button>
              </div>
              </div>  
          </form>
        </div>
</div>
</div>
<div v-show="activeSection === 'blocks'" id="sheet-container" class="flex flex-col w-full items-center justify-center">
  <div class="w-full mt-3">
  <label for="default-search" class="mb-2 text-sm font-medium text-gray-900 sr-only dark:text-white">Search</label>
  <div class="relative">
      <div class="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
          <svg class="w-4 h-4 text-gray-500 dark:text-gray-400" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20">
              <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m19 19-4-4m0-7A7 7 0 1 1 1 8a7 7 0 0 1 14 0Z"/>
          </svg>
      </div>
      <input  @input="performSearch" type="search" id="default-search" class="block w-full p-4 pl-10 text-sm text-gray-900 border border-gray-300 rounded-lg bg-gray-50 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500" placeholder="Search for a block..." required>
  </div>
</div>
<div class="flex w-full">
  <ul id="block-list" class="w-2/6 ml-3 mt-3 text-white">
    <span>Attack as selected monster.</span>
    <button @click.prevent="blocksFetchMonster()" class="bg-yellow-400 w-3/6 text-white font-bold mb-2 rounded">Fetch</button>
      <li class="text-3xl underline mb-1">Statblocks:</li>
      <li v-for="(block, index) in filteredblocks" :key="index" class="text-2xl mb-1 border-b-4 border-black">
        <a href="#" @click="loadBlock(block.id)">{{ block.name }}</a>
      </li>
</ul>
<div v-if="isNotEmptyObject(loadedBlock)" id="loaded-block" class="w-4/6 mt-3 ml-3 mr-3 stat_block flex flex-col">
   <span class="font-bold text-4xl underline">{{ loadedBlock.name }}</span>
   <span class="text-2xl">{{ loadedBlock.size }} {{ loadedBlock.type }}, {{ loadedBlock.alignment }}</span>
    <span class="text-1xl">Armor Class {{ loadedBlock.armor_class }}</span>
    <span class="text-1xl">Hit Points {{ loadedBlock.hit_points }}</span>
    <span class="text-1xl">Speed {{ loadedBlock.speed }}</span>
    <hr />
    <div class="flex flex-col">
    <div class="flex pt-2">
    <div class="flex flex-col w-3/6">
    <span class="text-1xl">STR</span>
    <span class="text-1xl">{{ loadedBlock.strength }} ({{ calculateModifier(loadedBlock.strength)}})</span>
    </div>
    <div class="flex flex-col w-3/6">
      <span class="text-1xl">DEX</span>
      <span class="text-1xl">{{ loadedBlock.dexterity }} ({{ calculateModifier(loadedBlock.dexterity)}})</span>
      </div>
      </div>
      <div class="flex pt-2">
      <div class="flex flex-col w-3/6">
        <span class="text-1xl">CON</span>
        <span class="text-1xl">{{ loadedBlock.constitution }} ({{ calculateModifier(loadedBlock.constitution)}})</span>
        </div>
        <div class="flex flex-col w-3/6">
          <span class="text-1xl">INT</span>
          <span class="text-1xl">{{ loadedBlock.intelligence }} ({{ calculateModifier(loadedBlock.intelligence)}})</span>
          </div>
        </div>
        <div class="flex pt-2 pb-2">
          <div class="flex flex-col  w-3/6">
            <span class="text-1xl">WIS</span>
            <span class="text-1xl">{{ loadedBlock.wisdom }} ({{ calculateModifier(loadedBlock.wisdom)}})</span>
            </div>
            <div class="flex flex-col  w-3/6">
              <span class="text-1xl">CHA</span>
              <span class="text-1xl">{{ loadedBlock.charisma }} ({{ calculateModifier(loadedBlock.charisma)}})</span>
              </div>
              </div>
    </div>
    <hr />
    <span class="text-1xl"><b>Senses</b> {{ loadedBlock.senses }}</span>
    <span class="text-1xl"><b>Languages</b> {{ loadedBlock.languages }}</span>
    <span class="text-1xl"><b>Challenge</b> {{ loadedBlock.challenge_rating }}</span>
    <hr />
    <template v-for="(array) in loadedBlock.special_abilities">
      <template v-for="(values, keys) in array">
    <span class="text-1xl mt-1"><b>{{ keys }}: </b>{{ values }}</span>
    </template> 
    </template>
    <hr />
    <span class="text-2xl mt-1 mb-1 border-b-2 border-black">Actions</span>
    <template v-for="(array) in loadedBlock.actions">
      <template v-for="(values, keys) in array">
    <span class="text-1xl mt-1"><b>{{ keys }}: </b>{{ values.description }}</span>
    <div class="flex">
        <button class="bg-red-400 w-3/6 text-white mr-1 font-bold mb-2 rounded" @click.prevent="rollMonsterActionHit(values.attack_bonus, keys, 'monsterAttack')">Roll Hit</button>
        <button class="bg-red-400 w-3/6 text-white font-bold mb-2 rounded" @click.prevent="rollMonsterActionDamage(values.man_dam, value.man_dam_bonus)">Roll Damage</button>
      </div>
    </template> 
    </template>
  </div>
</div>
</div>
<div v-show="activeSection === 'admin'" class="flex flex-col w-full items-center justify-center text-white">
  <div class="font-white" v-for="(player, key) in players">
    <span>{{ player.id }}</span>
    <span>{{ player.name }}</span>
  </div>
  <div class="flex flex-col w-full">
    <span class="m-1  text-lg mt-3">Give a Player an Item.</span>
    <select  class=" m-1 text-black w-3/6" @change="onSelectItem">
      <option v-for="(item, key) in items" :key="key" :value="item.id">{{ item.name }}</option>
    </select>
  </div>
  <div class="flex flex-col w-full">
    <span class="m-1  text-lg mt-3">Generate a magical item</span>
    <span class="m-1  text-md mt-3">Here, you can generate a magical item and if you like it, add it to the database.</span>
    <button class="bg-blue-500 w-3/6 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded" @click.prevent="generateMagicalItem()">Generate</button>
  </div>
</div>
<!--<div v-show="activeSection === 'resources'" class="flex flex-col w-full items-center justify-center text-white">
</div> --> 
<div v-show="activeSection === 'itemDB'" class="flex flex-col bg-white w-full items-center justify-center text-white">
    <table class="w-auto table-auto text-left text-lg">
      <thead class="bg-gray-500 text-white">
        <th class="px-4 py-2">Name</th>
        <th class="px-4 py-2">Description</th>
        <th class="px-4 py-2">Category</th>
      </thead>
      <tr v-for="(item, key) in items" class="text-black bg-white border-b border-gray-300"  @click="ShowItemDetails(item.attributes)">
        <td  class="font-bold px-4 py-2">{{ item.name }}</td>
        <td class="px-4 py-2">{{ item.description }}</td>
        <td class="px-4 py-2">{{ item.item_type.name }}</td>
      </tr>
    </table>
</div>
</div>
</body>
</html>
<script type="application/javascript">

function onStateChangeEvent(msg) {

}

    const VueApp = new Vue({
      el: '#app',
      data: {
        message: 'My Sheets',
        characters: [],
        skills: [],
        blocks: [],
        activeSection: 'sheets', // Default active section
        activeSheetTab: 'core', // Default active sheet tab
        searchQuery: '',
        loadedBlock: {},
        players: [],
        player: {},
        playersCreatures: [],
       // resources: [],
        activeSheet: '',
        mappings: [],
        items: [],
        rollData: [],
        updateMessage: "",
        selectedSlot: '',
        DMselectedCreature: {},
        managedItems: {},
        rarityColors: {
            1: 'border-gray-500',      // Example colors, you can customize these
            2: 'border-green-500',
            3: 'border-blue-500',
            4: 'border-purple-500',
            5: 'border-orange-500'
        },
        openMenus: {},
        basicItems: { 
          0: "Shortsword", 1: "Shortbow", 2: "Dagger", 3: "Club", 4: "Light Mail"

        },
        
      },
      async created() {

        var mappings = await fetchMappings();
        VueApp.mappings = mappings;
        var skills = await fetchSkills();
        var players = await getPlayers();
        var blocks = await fetchBlocks();
        VueApp.skills = skills;
        VueApp.blocks = blocks;
        VueApp.players = players;
        var player = await getUser();
        VueApp.player = player;
        var data = await initSheet(player);
        var creatures = await getUsersCreatures(player.id);
        //var resources = await getUsersResources(player.id);
        //VueApp.resources = resources;
        VueApp.playersCreatures = creatures;
        var items = await fetchItems();
        VueApp.items = items;
        await VueApp.filterSheetItems(data.characters);
        await VueApp.getSheetSpells(data.characters);
        await VueApp.processSheet(data.characters, VueApp.mappings)
      },
      computed: {
      filteredblocks() {
      return this.blocks.filter(block =>
        block.name.toLowerCase().includes(this.searchQuery.toLowerCase())
      );
    },
    spellsToShow() { } 
  },
      methods: {


        async fetchSpellLevels(level_id) {
        try {
          const level = await getSpellLevelAPI(level_id);
          return level.level;
        } catch (error) {
          console.error(error);
          spellLevels.push(null);
        }
    
    },

    generateMagicalItem() {
      // Select a random item from the basic items list, for testing though, always select "Light Mail"
      let item = this.basicItems[4];
      // We need to get a random buff from the API, for testing we will use the buff for "Adamantine_Armour"
      let buff = {"id": 4, "name": "adamantine_armour", "effects": {"meta": "This suit of armour is reinforced with adamantine, one of the hardest substances in existence. While you're wearing it, any critical hit against you becomes a normal hit."}, 
      "keywords": {"prefix_adjectives": "impenetrable, impervious, stalwart",  "suffix_adjectives": "impervious, stalwart"} }
      // we will worry about rarity later.
      let rarity = 1;
      // pick either a prefix or a suffix for the item based on the buff keywords
      let prefixOrSuffix = Math.floor(Math.random() * 2);
      // if prefix, pick a random prefix adjective from the buff keywords, if suffix a random suffix adjective
      let adjective = prefixOrSuffix === 0 ? buff.keywords.prefix_adjectives.split(",")[Math.floor(Math.random() * buff.keywords.prefix_adjectives.split(",").length)] : buff.keywords.suffix_adjectives.split(",")[Math.floor(Math.random() * buff.keywords.suffix_adjectives.split(",").length)];
      // if prefix capitalize the first letter of the adjective
      if(prefixOrSuffix === 0) {
        adjective = adjective.charAt(0).toUpperCase() + adjective.slice(1);
      }
      // if prefix name will be
      let name = prefixOrSuffix === 0 ? adjective + " " + item : item + " of the " + adjective;
      console.log(name);
    },
    calculateModifier(abilityScore) {
      return Math.floor((abilityScore - 10) / 2);
    },
    findSkillProf(skills, id) {

      return skills.includes(id)
    },
    shortenStat(stat) {
      return stat.substring(0, 3).toUpperCase();
    },
    removeUnderline(string) {
      return string.replace(/_/g, ' ');
    },
    showSection(section) {
                    this.activeSection = section;
    },
    performSearch(event) {
      this.searchQuery = event.target.value;
    },
    loadBlock(id) {
      // get the block from the blocks array
      var block = this.blocks.find(block => block.id === id);
      // set the loadedBlock to the block
      this.loadedBlock = block;
      

    },
    isNotEmptyObject(value) {
      // check if the value is an object and it isn't empty
      return typeof value === 'object' && Object.keys(value).length > 0;
    },
    hasSheet(e) {
      // check if the character is being pulled back from the API.
      var character = this.characters.find(character => character.talespire_id === e);
      // check if character OR character.sheet is an object and it isn't empty
      if(character === undefined || character.sheet === undefined || character.sheet === null) {

        return false;
      } else {
        return true;
      }
    },
    async refreshCreatures() {
        var data = await initSheet(VueApp.player);
        var creatures = await getUsersCreatures(data.talespire_id);
  //  var resources = await getUsersResources(data.id);
      //  VueApp.resources = resources;
        VueApp.playersCreatures = creatures;
        await VueApp.filterSheetItems(data.characters);
        await VueApp.getSheetSpells(data.characters);
        await VueApp.processSheet(data.characters,  VueApp.mappings);

},
async createSheet(creatureID) {
    // id = users TS id
    let id = VueApp.player.id;
    // search player creatures for matching id and send it as data
    let data = VueApp.playersCreatures.find(creature => creature.id === creatureID);
    let preparedData = {
      id: data.id,
      name: data.name,

    };
    sheet = await createSheet(id, preparedData);
    return sheet;

},
displayResource(resource) {
  console.log(resource);

  },
  setActiveSheet(creatureID) {
    // find the character id based on the passed talespire_id and set the id to the value of activeSheet
    let sheet = this.characters.find(character => character.talespire_id === creatureID).id;
    this.activeSheet = sheet;
  },
  ShowItemDetails(item) {
    // get the table row
    let td = event.target.parentNode;
    // if next sibling is div, remove it
    if(td.nextSibling.tagName === 'DIV') {
      td.nextSibling.remove();
    }
    // create a div
    // for each item key in the item object create a div with the key and value
    let div = document.createElement('div');
    for (const [key, value] of Object.entries(item)) {
      // set the div innerHTML to the value
      div.innerHTML += this.removeUnderline(key) + ": " +  value + " | ";
      // the div should be after the td, not in it
      td.after(div);
    }

  },
  onSelectItem(e) {
      // This function creates a pop-up window with the item details, which will have a button in it to add the item to the sheet.
      // get the item id from the event
      let itemID = e.target.value;
      // get the item from the items array
      let item = this.items.find(item => item.id == itemID);
      // create a div
      let form = document.createElement('form');
      // give the div text-white class
      form.classList.add('text-black', 'flex', 'flex-col', 'w-11/12', 'mt-2');
      // for each item key in the item object create a div with the key and value
      // create a select with a list of all player characters
      let select = document.createElement('select');
      // give the select a class
      select.classList.add('w-full', 'bg-white', 'border', 'rounded', 'border-gray-400', 'focus:outline-none', 'focus:ring', 'focus:border-blue-300');
      // for each character in the characters array
      // in the future this will have to be an API call that gets all the characters for several players.
      for (const character of this.characters) {
        // create an option
        let option = document.createElement('option');
        // set the option value to the character id
        option.value = character.id;
        // set the option innerHTML to the character name
        option.innerHTML = character.name;
        // append the option to the select
        select.appendChild(option);
      }
      // append the select to the div
      form.appendChild(select);




      // create a button
      let button = document.createElement('button');
      // give classes bg-blue-500 w-3/6 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded 
      button.classList.add('bg-blue-500', 'w-3/6', 'hover:bg-blue-700', 'text-white', 'font-bold', 'py-2', 'px-4', 'rounded', 'mt-2');
      // set the button innerHTML to "Add to sheet"
      button.innerHTML = "Give " + item.name;
      // add an event listener to the button
      button.addEventListener('click', function(e) {
        e.preventDefault();
        // call the add item function - this will be in brains.js for the API query.
        addItemToPlayerSheet(itemID, select.value);
      });
      // put the button inside the div
      form.appendChild(button);
      // append the div to the body
      document.body.appendChild(form);
    },
    truncateString(str, maxLength) {
      if (str.length <= maxLength) {
        return str;
      } else {
        return str.slice(0, maxLength) + "...";
      }
    },
    // item = payload characterID = unique ID of the character in the database, typeString = "item" or "attack" for roll processing.
    async  useConsumable(sheetItem, characterID, typeString) {

// when a player clicks "Consume on the relevent item in the character sheet, this function is called."
   // first it needs to update the quantity of the item in the database. (this is done by the API)
      // we also need to allow for a diceRoll in talespire.
      // get first part of .consume (before comma)
      console.log("Using consumable:")
      console.log(sheetItem);
      if (sheetItem.item.attributes.hasRoll == true) {
      let string = { "name": sheetItem.item.name, "roll": sheetItem.item.attributes.consume};
      dice = await TS.dice.putDiceInTray([string]);
      // put the item data and the dice roll into a string and add it to the rollData array
      // this will be used in the rollDice function to roll the dice.
      this.rollData.push({"character_id": characterID,"item": sheetItem, "rollID": dice, "type": typeString});
      }
      else {
        // If the potion doesn't require a roll of the dice then we need to look at the item attributes and see what it does.
        switch(sheetItem.item.attributes.type) {
            case "buff": {
              // If the item is a buff, then we need to get the "buff_id" and do a lookup in the buffs table via the API.
              let buff = await getBuff(sheetItem.item.attributes.buff_id);
              // buffs will have X keys, but will either be the name of a field in the character sheet, or a "meta" key which functions as a description.
              // we need to loop through the keys and if the key is a field in the character sheet, then we need to update the character sheet via the API
              // if the key is "meta" then we need to add the value to the meta array in the character sheet.
              for (const [key, value] of buff.effects) {
                if (key == "meta") {
                  // add the meta value to the meta array in the character sheet.
                  //addBuffToCharacterSheet(characterID, buff)
                }
                else {
                  // update the character sheet via the API
                  let data = { key: value};
                  let update = await updateCharacterSheet(characterID, data);

                }
              }
              let character = VueApp.characters.find(character => character.id == characterID);
              VueApp.updateMessage = sheetItem.item.name + " was consumed by "  + character.name;
            }


        }
        // deduct the consumable
        await deductItemFromPlayerSheet(sheetItem.id);

      }
},
async removeBuff(characterID, buffID) {

  await removeBuffFromCharacterSheet(characterID, buffID);
  await VueApp.refreshCreatures();

},
async addBuff(characterID, buffID) {
  // this function will add a buff to the character sheet, and then refresh the character sheet.
  await addBuffToCharacterSheet(characterID, buffID);
  await VueApp.refreshCreatures();
},
async equipItem(characterID, itemID, slot) {
  await equipItemToCharacterSheet(characterID, itemID, slot);
 // we need to get the buff/s from the item and add them to the character sheet.
      // from the itemID we need to get the item from the items array.
  //let itemFromDB = await getItem(itemID);
  // we need to get the buff/s from the item and add them to the character sheet.
  //if(itemFromDB.attributes.buff_id != null) {
    // if the item has a buff_id, then we need to add the buff to the character sheet.
   // let buff = await VueApp.addBuff(characterID, itemFromDB.attributes.buff_id);
 // }
  // wait 5 seconds then refresh the character sheet.
  await VueApp.refreshCreatures();
  
  
  
  //manageItemType(characterID, itemID)
  //VueApp.updateMessage = VueApp.characters.find(character => character.id == characterID).name + " equipped " + itemFromDB.name + " as their " + slot + ".";
  

},
async unEquipItem(characterID, itemID) {
  // this function will unequip an item from the character sheet, and then refresh the character sheet.
  await unEquipItemFromCharacterSheet(characterID, itemID);
  // once the item has been unequipped, we need to remove any buff it was providing
  // The item will have an attribute of "buff_id" which will be the id of the buff in the buffs table.
  // we need to remove the buff from the character sheet.
  let character = VueApp.characters.find(character => character.id == characterID);
  let item = character.sheet.sheetsItems.value.find(item => item.id == itemID);
  console.log(item);
  await removeBuffFromCharacterSheet(characterID, item.item.attributes.buff_id);
  await VueApp.refreshCreatures();
},
getEquippedItemForBuff(characterID, buffID) {
  // this will return true if the character has the item equipped that is required for the buff, it means an item being equip is causing the buff and the item needs to be unqeuipped to remove it.
  let character = VueApp.characters.find(character => character.id == characterID);
  if(character.sheet != null) {
  // search for all items that are equipped and return true if an equip item matches the buffID,character.sheet.items.value is the array to search
  let equippedItem = character.sheet.sheetsItems.value.find(item => item.isEquipped == true && item.item.attributes.type == "buff" && item.item.attributes.buff_id == buffID);
  if (equippedItem != null) {
    return true;
  }
  else {
    return false;

  }
}

},
async getSpell(spellID) {
  // this function will return the spell from the spells array.
  let spell = await getSpellFromDB(spellID);
  return spell;
},
filterByEquipped(item) {
  // takes an array of items and only return the item if it is equipped.
  return item.isEquipped == true;
},
async makeAttackRoll(characterID, item, typeString) {
  // always a d20 roll
  let string = { "name": "Attack with " + item.name, "roll": "1d20" };
  dice = await TS.dice.putDiceInTray([string]);
  this.rollData.push({"character_id": characterID,"item": item, "rollID": dice, "type": typeString});

},
async makeDamageRoll(characterID, item, typeString) {

  // calculate the amount of dice to roll.
  let string = { "name": "Damage with " + item.item.name, "roll": item.item.attributes.damage };
  dice = await TS.dice.putDiceInTray([string]);
  this.rollData.push({"character_id": characterID,"item": item, "rollID": dice, "type": typeString});


},
async blocksFetchMonster() {

  this.loadedBlock = {};
  let details = await TS.creatures.getSelectedCreatures();
  details = await TS.creatures.getMoreInfo(details);
  this.DMselectedCreature  = details[0];
  // for the selected creature, find the name and search the blocks array for a close matching name
  this.blocks.forEach(function (block, index) {
    let blockNameLower = block.name.toLowerCase();
    let searchTermParts = details[0].name.toLowerCase().split(' ');
    let  foundMatch = searchTermParts.some(part => blockNameLower.includes(part));
    if (foundMatch) {
      // if the block name includes the details name, then load the block.
      VueApp.loadBlock(block.id);
      return;
    }
    else {

      console.log("no match found.");

    }
  });

},
async rollMonsterActionHit(attackBonus, attackName, typeString) {
  
  let string = { "name": this.DMselectedCreature.name + " attacks with " + attackName, "roll": "1d20" };
  dice = await TS.dice.putDiceInTray([string]);
  this.rollData.push({"creature": this.sDMselectedCreature,"bonus": attackBonus , "rollID": dice, "type": typeString});




},
// Prepares the itemCount object for the character sheet.
async filterSheetItems(characters) {
  characters.forEach(function (character, index) {
      if (character.sheet != null) {
      character.sheet.ItemCounts = {};
        // we need to get each item_id in the sheetsItems array and count how many times it appears for each item and add it to the ItemCounts object as a key value pair. 
        character.sheet.sheetsItems.forEach(function (item, index) {
          if (character.sheet.ItemCounts[item.item.id] == undefined) {
            character.sheet.ItemCounts[item.item.id] = 1;
          }
          else {
            character.sheet.ItemCounts[item.item.id] += 1;
          }
        });

      }
});
      },
async getSheetSpells(characters) {

  await characters.forEach(function (character, index) {
      if ( character.sheet != null) {
        character.sheet.spellData = {};
        if (character.sheet.spells != null) {
        // if the character has spells, then we need to get the spells from the spell character.sheet.spells.value.spell_list and add them to the character.sheet.spellData object. we have a getSpell function we can call for each one.
        if (character.sheet.spells != undefined || character.sheet.spells != null) {
        character.sheet.spells.spell_list.forEach(async function (spell, index) {
            // get the spell from the API
            let spellFromDB = await VueApp.getSpell(spell);
            // add the spell to the character.sheet.spellData object.
            character.sheet.spellData.value[index] = spellFromDB;
            // add the spell level to the character.sheet.spellData object.
            let level = await VueApp.fetchSpellLevels(character.sheet.spellData.value[index].id);
            character.sheet.spellData.value[index].level = level;
        });
      }
    }
      
      
      
      
      
      
      }





  })


},
      async getItemFromApi(id) {

        let item = await getItem(id);
        return item;
      },
      manageItemType(character, itemId) {

        // This function looks up all of the items with the matching id in the sheetsItems array and sets them as managedItems.
        // clear the managedItems array first
        character.sheet.managedItems.value = {};
        // loop through the sheetsItems array and find all items with the matching id
        character.sheet.sheetsItems.value.forEach(function (item, index) {
          if (item.item.id == itemId) {
            // if the item is found, add it to the managedItems object, using the array key as the key.
            character.sheet.managedItems.value[index] = item;
            // add VueApp.managedItems into a new object in the sheet
          }
        });
      

      },
      openMenu(itemId) {
      // if the menu that is clicked is already open, then close it.
      if (this.openMenus[itemId] == true) {
        this.openMenus[itemId] = false;
        return;
      }
      else {
      this.openMenus = {};
      this.$set(this.openMenus, itemId, !this.openMenus[itemId]);
      }
    },

    
    async processSheet(data, mappings) {

// This function will go through each data.characters.sheets and map the keys to the correct type, for logic in vue JS, e.g. if the key is "class" then the type is "B", for "Basic" and so on.
// This will allow us to use the same logic for each sheet, and not have to worry about the type of sheet we are dealing with.
// we will edit the data.characters.sheets object in place, and return it.
// for each character data[x]
data.forEach(function (character, index) {
// First we need to get the keys of the data.characters.sheets object, and then we can loop through them.
if(character.picture && character.picture.data) {
var image = new Blob([new Uint8Array(character.picture.data)]);
data[index].picture = URL.createObjectURL(image);
};  
// if character has a sheet object exists
if (character.sheet != null) {
character.sheet.managedItems = {};
var keys = Object.keys(character.sheet);
for (var i = 0; i < keys.length; i++) {
    // Now we have the keys, we can loop through them and check the mappings object to see what type of key it is.
    var key = keys[i];
    // we need to match this key to the mappings object, and get the type, this is not the index of the mappings array, but we need to exclude the "skills key"
    var type = mappings.find((element) => element.sheets_field_name == key);
    if (type == undefined) {
    // if the type is undefined, then we need to add a field_type of "U" for "Unknown"
    type = "U";
    }
    else {
    type = type.field_type;
    }
    // now we need to add in the type to the data.characters.sheets object.
    data[index].sheet[key] = {
    type: type,
    value: character.sheet[key],
    };
}
if (character.sheet.sheetsItems != null) {
// here we get a count of all the same items in the items array, and add a count object for each item.
character.sheet.sheetsItems.value.forEach(function (item, index) {
    // if shees_items.is_equipped == true AND has a an attributes.type of "buff" then we need to add the buffs to the character sheet
    if (item.isEquipped == true && item.item.attributes.type == "buff") {
    // if a buff exists in character sheet for this equip item, do nothing, else add the buff to the character sheet.
    if(character.sheet.buffs.value.find((element) => element.id == item.item.attributes.buff_id)) {
        // do nothing

    }
    else {
        // addBuffToCharacterSheet
        let addBuff = addBuffToCharacterSheet(character.id, item.item.attributes.buff_id);



    }


    }
});
}
}
});
// push data into vue app.
VueApp.characters = data;
console.log(VueApp.characters)
// set activeSheet to be the ID of the first character in the array.
VueApp.activeSheet = data[0].id;
console.log("Finished processing sheet");
}

      

      


      },directives: {
    enlarge: {
      bind(el, binding) {
        var isEnlarged = false;
        if (isEnlarged) {
          el.classList.add('enlarge-animation');
          setTimeout(() => {
            el.classList.remove('enlarge-animation');
          }, 500);
      }
    },update(el, binding) {
        // if value is different from previous value
        if (binding.value !== binding.oldValue) {
          // then toggle the class
          el.classList.toggle('enlarge-animation');
          setTimeout(() => {
            el.classList.remove('enlarge-animation');
          }, 5000);
        }
    
    }
  }
  
      }
    });

    function UpdateSheet(id) {
    
    }
    
</script>
<style>
    * {
    
        font-family: 'IM Fell English SC', serif;
      
}


.stat_block {

  background-color: #f5f5f5;
    border: 1px solid #ccc;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  padding: 3em;

}

.parchment {

  display: flex;
  flex-direction: column;
  
    padding: 2em;
    background-color: #f5f5f5;
    border: 1px solid #ccc;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.parchment_header {

    font-weight: bold;
  margin-bottom: 10px;
  color: #333;
    
}

.img-border {

    border: 5px ridge #A49319;

}

.enlarge-animation {
  /* this animation should make the text larger */
  transform-origin: top left;
  animation: enlargeInput 2s forwards; /* Apply the animation */
}

@keyframes enlargeInput {
  0% {
    transform: scale(1);
    /* Start with original size */
  
  }
  50% {
    transform: scale(1.3); /* Reach the larger size at 50% */
    /* Make the element invisible */
    font-weight: bold;
  }
  100% {
    transform: scale(1); /* End back at original size */
    /* Restore visibility */
    font-weight: initial;
  }

}

@keyframes glow {
  0% {
    box-shadow: 0 0 5px 0 blue; /* Initial shadow */
  }
  100% {
    box-shadow: 0 0 20px 5px blue; /* Glowing shadow */
  }
}

.used-diamond {

  width: 20px;
  height: 20px;
  background-color: black;
  margin-top: 2px;
  clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);



}

.diamond {
  width: 20px;
  height: 20px;
  background-color: blue;
  margin-top: 2px;
  clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
  animation: pulse 2s infinite alternate; /* Add the glow animation */
}

@keyframes pulse {
  0% {
    transform: scale(1);
    box-shadow: 0 0 10px 5px blue;
  }
  50% {
    transform: scale(1.1); /* Scale up slightly at 50% of the animation */
    box-shadow: 0 0 15px 7px blue; /* Increase the shadow size */
  }
  100% {
    transform: scale(1);
    box-shadow: 0 0 10px 5px blue;
  }
}
</style>
